\chapter[Metodologia]{Metodologia}

\section{Desenvolvimento do Firmware}
\subsection{Ambiente de Desenvolvimento}
O firmware foi desenvolvido para a placa WeAct ESP32-C3FH4, baseada no microcontrolador ESP32-C3 da Espressif (China), que opera com arquitetura RISC-V de 32 bits, frequência de até 160 MHz, 400 kB de RAM, 384 kB de ROM, 4 MB de FLASH e até 22 pinos GPIO programáveis \cite{weact_esp32c3}. Foi utilizada a linguagem MicroPython na versão 1.24.1, compatível com a arquitetura da placa, cuja imagem de firmware foi obtida no site oficial do projeto \cite{micropython_esp32c3_download}. A gravação do firmware e a transferência dos scripts foram realizadas por meio da Thonny IDE, comumente adotado para aplicações com MicroPython \cite{thonny_ide}.

\subsection{Estruturação do Projeto e Modularização}
A arquitetura do firmware foi organizada em três diretórios principais (\texttt{lib}, \texttt{data}, \texttt{tasks}) complementados pelo arquivo \texttt{main.py}, responsável por coordenar a inicialização do sistema. No diretório \texttt{lib}, foram alocadas bibliotecas específicas, incluindo a \texttt{aioble}, uma biblioteca recomendada pela própria documentação do MicroPython para a maioria das aplicações com Bluetooth Low Energy (BLE) \cite{micropython_ble_docs}. Essa biblioteca abstrai a complexidade das operações de conexão, emparelhamento e troca de dados via GATT, facilitando a implementação de servidores BLE no ESP32-C3 \cite{aioble_repo}. O subdiretório \texttt{utils} concentrou módulos auxiliares, como \texttt{bluetooth\_config.py}, para definição de parâmetros de conexão, e \texttt{data\_converter.py}, para serialização dos dados trocados com o aplicativo Android.

A persistência de configurações operacionais foi implementada no diretório \texttt{data} através do arquivo \texttt{config.json}, complementado por um conjunto de valores padrão em \texttt{default\_data.py} como mecanismo de segurança para cenários de corrupção de dados salvos.

\subsection{Gestão de Tarefas Assíncronas}
A lógica central do firmware foi desenvolvida no arquivo \texttt{main.py}, onde foram instanciadas cinco corrotinas principais utilizando o módulo \texttt{asyncio} do MicroPython. A função \texttt{main()} coordena:

\begin{itemize}

    \item \texttt{peripheral\_task()}, responsável pelo ciclo de vida das conexões BLE;
    \item \texttt{send\_heartbeat\_task()}, que emite pacotes de sincronização a cada 2 segundos contendo métricas de integridade do sistema utilizando o módulo utilitário \texttt{memory\_usage.py};
    \item \texttt{read\_task()}, dedicada ao processamento de dados recebidos via Bluetooth com despacho para handlers especializados;
    \item \texttt{malting\_task()}, núcleo do controle do processo de malteação.
    \item \texttt{sensors\_task()}, que gerencia a leitura periódica dos sensores instalados.


\end{itemize}

\begin{figure}[ht]
    \centering
    \caption{Esquema geral do projeto com as tarefas assíncronas em evidência}
    \label{fig:TarefasAssincronasFluxograma}
    \includegraphics[width=1.0\textwidth]{TarefasAssincronas.drawio.png}

    {\centering\footnotesize Fonte: Autoria própria.\par}
\end{figure}

A separação funcional foi estendida no diretório \texttt{tasks}, onde cada módulo encapsula comportamentos específicos: \texttt{parameters\_task.py} gerencia atualizações dinâmicas de parâmetros operacionais, enquanto \texttt{task\_handler.py} implementa um padrão de mediador para roteamento de comandos baseado no primeiro byte dos pacotes recebidos.

\subsection{Algoritmos de Controle do Processo de Malteação}
A sequência de maceração, germinação e secagem foi modelada no subdiretório \texttt{malting\_stages} em módulos especializados (\texttt{steeping.py}, \texttt{germination.py}, \texttt{kilning.py}). Cada etapa opera como uma corrotina independente, monitorando variáveis críticas com base nas condicionais dos parâmetros recebidos via Bluetooth. A estrutura assíncrona permitiu a execução não bloqueante desses processos, essencial para a continuidade da comunicação Bluetooth mesmo durante o processo. As lógicas de marcação de tempo foram desenvolvidas com o uso do módulo utilitário \texttt{uptime.py}, que se baseia no tempo total de execução do dispositivo.

\begin{figure}[ht]
    \centering
    \caption{Fluxograma do controle planejado para o algoritmo de malteação.}
    \label{fig:logicamalteacao}
    \includegraphics[width=1.0\textwidth]{logicamalteacao.png}

    {\centering\footnotesize Fonte: Autoria própria.\par}
\end{figure}



% Esta estrutura modular e documentada, combinada com o versionamento no GitHub, não apenas atende aos requisitos imediatos de controle do malteador, mas serve como modelo reutilizável para outros sistemas de automação laboratorial na instituição, objetivo explícito do trabalho conforme estabelecido no escopo pedagógico do LACEMP-IFES.


\section{Desenvolvimento do Aplicativo}
\subsection{Ambiente e Ferramentas de Desenvolvimento}

O ambiente de desenvolvimento foi estabelecido utilizando a IDE Android Studio (Koala Feature Drop - 2024.1.2) com linguagem Kotlin na versão 1.9.10. Os testes foram conduzidos em um dispositivo físico com Android 14, garantindo compatibilidade com as APIs mais recentes do sistema operacional. Escolheu-se o ecossistema Android Jetpack como base tecnológica devido a sua estabilidade e suporte oficial da plataforma Google para desenvolvimento de aplicativos.

\subsection{Arquitetura e Padrões de Projeto}

Adotou-se uma arquitetura em camadas conforme as diretrizes de boas práticas do Android Moderno, estruturada em três módulos principais: \textit{data}, \textit{domain} e \textit{presentation}. O módulo \textit{data} concentra a gestão de fluxos de informação, incluindo comunicação Bluetooth e operações de banco de dados local através das bibliotecas Room e DataStore. Na camada \textit{domain}, implementou-se a lógica de negócios e tratamento de dados, incluindo a normalização de parâmetros de processo e validação de entradas. A camada de \textit{presentation} foi desenvolvida com Jetpack Compose, seguindo os princípios de Design Material 3 para se obter uma interface intuitiva.

\subsection{Modularização e Injeção de Dependências}

Visando a manutenibilidade, o projeto empregou o padrão de injeção de dependências através da biblioteca Dagger Hilt. Esta abordagem permitiu a desacoplamento entre componentes, promovendo melhor a manutenibilidade do projeto como um todo. 

\subsection{Integração Bluetooth e Gestão de Dispositivos}

A comunicação com o hardware ESP32 foi implementada através da API Android Bluetooth Low Energy (BLE), utilizando o padrão GATT para transferência de dados. Desenvolveu-se um serviço em segundo plano para gerenciamento assíncrono da conexão, capaz de manter a estabilidade da ligação mesmo durante mudanças de estado do aplicativo. Para persistência local, implementou-se um repositório combinando SQLite (via Room) para armazenamento de receitas e DataStore para armazenamento das preferências do usuário, como o tema do aplicativo (escuro ou claro).

% \subsection{Compilação}

% !!!TODO Em algum momento eu realmente preciso compilar esse aplicativo pra .apk!!!

\section{Documentação}
A gestão do código foi implementada mediante a utilização do sistema de controle de versão Git, com hospedagem pública em dois repositórios GitHub dedicados: um para o firmware \url{https://github.com/NicolasDezan/ESP32C3-MaltingControl.git} e outro para o aplicativo Android \url{https://github.com/NicolasDezan/MALT-ESP.git}. A separação em repositórios distintos buscou garantir a modularidade entre os componentes de software, além de facilitar a manutenção independente de cada projeto.

% \subsection{Tutoriais}
% Talvez eu grave tutoriais mostrando os códigos e o sistema funcionando etc etc etc
% Se sobrar tempo e se os videos ficarem legais eu vou incluir uma fala do tipo:
% A documentação técnica incluiu tutoriais em vídeo externos (links no arquivo \texttt{README.md}) detalhando processos críticos como configuração inicial do ESP32-C3 e emparelhamento Bluetooth.